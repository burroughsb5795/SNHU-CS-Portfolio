# Grocer
This project created a program that was able to take input from a file that contained a long list of items in a grocery store, that we used as stock and then turn that list into a more easily digestable format. There were 4 different options available from the menu, these included creating a histogram, creating a list that printed every item on the list and how many times it appeared, and the ability to search a specific item. The fourth option would exit the loop and end the program. 
I think I did a good job of making my code pretty simple. Although this was the last project we did for the course, this code was much easier to understand than the second project that I did in my opinion. This was also my first time using switch and maps in a project, so I was pretty proud of that.
I believe that I could do a better job in making comments. My comments are pretty bare bonesed and just give the general gist of what a line is doing, but I could put more thought into it while doing the coding instead of adding them as an afterthought.
Using maps was the most challenging. I wasn't really sure at first how to use the list provided efficiently, but through a lot of googling and time on StackOverflow I found this solution and it worked fantastically. It allowed my code to be much easier to read and efficient, and I will definitely be adding it to my arsenal from now on.
The use of switch makes this project much easier to update later on down the line. You would just need to add another case in order to add a new command.


CS300:

This Course was incredibly challenging at the start, learning a bunch of new algos and data structures was overwhelming at first, as well as learning big O notation. Eventually, once all the groundwork was laid, I got the hang of everything and come time to create the final project I felt pretty comfortable with the material. I learned how important it is to understand data structures, so that we can always make the correct choice for a project. Choosing the correct structure insures that our code can run as efficiently as possible. I spent a lot of time on Stack Exchange in order to better understand the materials and really be able to break it down more thoroughly. 


CS-250:

For me, interpreting user needs is the most difficult part of coding. A lot of my issues in other courses have come from not understanding what it is that a question is asking of me, and user stories resolves that problem a lot. It makes all the information easily accessible and easy to understand, so that I can focus on what really matters, which is coding and solving the problem. Currently, I'm bad about just programming away, and then compiling at the end instead of iterating and working through a program slowly and making sure everything works. I think in the future I'll attempt to use some agile principles in order to ensure that once I start working on bigger projects I'm not making mistakes that I'm missing until the very end and then chasing my tail trying to find it. I think in order to be a good team member, you need to know what you want from others, what they want from you, and be able to communicate that effectively. 

CS-230:

My client for this course was The Gaming Room. They are a company looking to expand their game, Draw It or Lose It, to different operating systems. We used a software design template in order to plan out our recommendations for this venture, and focused on a cloud-based architecture. I think my recommendations were very good at the end of the course. In the beginning I was kind of doing a lot of guess-work before I knew too much about cloud-based systems, but as the course progressed I learned more and in turn was able to make more solid recommendations for our client. Having clear goals laid out in the design document would be helpful when it comes to development. I would revise my earlier choices if I were to go back and revise my design document. In re-reading it I think it's clear that I lack too much knowledge on cloud-based systems at the time and I think that this type of project benefits from a cloud-based system. I considered the user's needs throughout the software design document, especially near the end of it. It's important to consider a user's needs as well as who the app will be serving when developing not just the design document but also the code itself, as without taking the user needs into account I would have more than likely chosen a more standard system architecture to develop this program on, as I'm more comfortable with it. However, upon learning more about cloud-based systems and the user's needs for expansion, it became clear that a cloud-based system was the way to go as it will allow for easy porting to other OSes in the future.

CS-305:

My client for this course was Artemis Financial, their goal was to modernize their application, and enhance the security of it. Our main task was to identify and mitigate potential security vulnerabilities and protect against external threats. The things that I did the best at were providing a comprehensive assessment of the vulnerabilities that we found, prioritized the most critical vulnerabilities that we found, and implement secure coding practices in order to prevent new vulnerabilities from being introduced in the future. It is important to implement secure coding practices and perform extensive vulnerability assessments in order to protect an organization's assets, reputation, and customer trust. Failure to do so can lead to data breaches, financial losses, and possibly even legal reprecussions. The most challenging aspect of the vulnerability assessment was figuring out how to supress vulnerabilities in the pom.xml file. We implemented HTTPS in order to add more secure communication between client and server, as well as using encryption algorithms to secure data. In the future, it will be incredibly helpful that I know how to create a SSL certificate, and provide secure communications for a system. For future employers, in this course I demonstrated my ability to conduct and interpret vulnerability assessments, I also demonstrated experience in prioritizing and mitigating those vulnerabilities. 


CS-320:

How can I ensure that my code, program, or software is functional and secure? In order to ensure that the code is secure and functional, we can use a multitude of tests to ensure everything is functioning properly. This includes unit testing to assess individual componoents, integration testing to evaluate interactions between modules, and system tests to verify the overall funtionality. Using automated test tools can also help to streamline the process and prevent human error.
How do I interpret user needs and incorporate them into a program? In order to interpret user needs, it's important to have effective communication with stakeholders and understand what they want from the program. This can be done by conducting user interviews, taking surverys, and creating prototypes to gather feedback and refine your understanding of the customer requirments. It's important to remain flexible throughout the process, as the user's needs may change throughout.
How do I approach designing software? It's important to start by defining clear objectives. This allows us a clear goal to work torwards. After this it's important to prioritize modularity and maintainability. This allows us to be able to adapt to different requests from the stakeholders without it becoming a great undertaking. It's important to iterate of the design based on feedback to create a responsive and adaptable program. Using these principles we can create software that is functional and secure.

CS-255:

Briefly summarize the DriverPass project. Who was the client? What type of system did they want you to design? The DriverPass project was a project that we made for a company whose goal was to create a way for driving students to take practice tests, classes, and schedule driving lessons. They wanted us to create a web-based application that met these requirements.
What did you do particularly well? I think I did a good job defining the user requirements
If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it? I would probably revise my acitivity diagrams in order to update and add Two-Factor Authentication. This would give users an extra layer of security that would be easy to implement and incredibly helpful.
How did you interpret the user’s needs and implement them into your system design? Why is it so important to consider the user’s needs when designing?  I used the interviews that we were provided in order to gain an understanding of what the main goals for this project were and focus on those requirements first and foremost. Once I had a good understanding of that, I began to add on smaller things that the customer requested but wasn't necessary to have a functional system.
How do you approach designing software? What techniques or strategies would you use in the future to analyze and design a system? It's important to start by defining clear objectives. This allows us a clear goal to work torwards. After this it's important to prioritize modularity and maintainability. This allows us to be able to adapt to different requests from the stakeholders without it becoming a great undertaking. It's important to iterate of the design based on feedback to create a responsive and adaptable program. Using these principles we can create software that is functional and secure.


CS-330:

This course and creating this project has given me a new appreciation for just how much work goes into creating any 3D environment. Previously, I had assumed that it was a decent sized undertaking to get things going in the initial phases of desiging a 3D space, such as creating an engine for a game when developing a video game. However, throughout this course I learned that creating something as simple as a small scene with cups and tissue boxes can be a massive undertaking. My development process involves a LOT of trial and error. I will attempt to do something with how I think it should work, test it, and then make adjustments. For example, creating the chopsticks I laid them out side by side on the table, then decided that I wanted a more interesting pose and wanted to lay one on top of the other. I began messing around with the rotation parameters until I eventually got something I was happy with. This allowed me to learn more about how rotation works, and when I began working on the flask I was able to much more quickly position the bar to attach the lid to the flask itself. Understanding computational graphics has given me a lot of new knowledge. Most importantly it gave me a real love for development. This course was by far the most challenging that I have taken thus far, but it was also the most rewarding. Seeing the progress I made week in and week out made a world of difference to me, and even though I spent more time on this class than other classes, I also had more fun in creating the scene for this project.


CS-340:
Writing programs that are maintainable, readable, and adaptable requires understanding and applying best practices and design principles thoughout the entire development process. When creating the project for this course, some ways that I kept this mind were using modular design to break the functionality of each operation down into smaller more managagable classes. For example, creating the CRUD Python module allowed me to define each operation with a clear purpose and making alterations to the module would not affect the dashboard inherently. Another example is using consistent naming conventions for variables in code. Using consistent conventions for variables makes code easier to understand for the next developer who comes along and tries to make sense of another programmer's code. Abstraction and maintenance are the two major benefits of implementing the CRUD module for this project. Abstraction allows me as a developer to focus on the logic in the application rather than worrying about database implementation constantly. It also means that making alterations to the database logic will only ever need to occurr in one place, simplifying the maintaining process. As a computer scientist, it's important to understand that not all projects are the same. For example, in this project we were creating a practical, real-world application that will allow a company to more easily help others by simplifying the process of finding the correct type of rescue dog. When it comes to projects like this, it's important to get everything right, as precision is of the utmost importance.

CS-350:
The purpose of this project was to create a prototype for a thermostat. We accomplished this goal by using the TI Launchpad CC3220, which hosts an array of features applicable to this project. I think my implementation of states and switch statements in this project meant that my code was incredibly functional, and met the criteria easily. I think the thing i could stand to improve on the most is using comments in order to make my code more clear to others. The biggest resource I found in this project is a group of people also taking classes here at SNHU that host a server where they can help each other understand and solve problems they're running into in their code. This will be an invaluable resource moving forward. I think understanding the physical hardware side of things will make courses in the future much easier to understand, as I will have a basic foundation for the learning on that end now.

CS-360:
The Weight Tracker app is designed to help users monitor their daily weight and achieve fitness goals through an intuitive, user-centered interface. The app includes essential features such as secure login, daily weight tracking, date selection, and SMS notifications for goal achievements. The development process emphasized modular design, iterative development, and thorough testing, ensuring a high-quality and adaptable product. Key challenges, such as effective database management and consistent UI design, were overcome through innovative solutions. The successful implementation of the weight tracking feature and date picker highlighted my skills in data management and user interaction.
